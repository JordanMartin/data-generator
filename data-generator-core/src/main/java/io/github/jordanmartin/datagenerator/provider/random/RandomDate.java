package io.github.jordanmartin.datagenerator.provider.random;

import io.github.jordanmartin.datagenerator.provider.annotation.Provider;
import io.github.jordanmartin.datagenerator.provider.annotation.ProviderArg;
import io.github.jordanmartin.datagenerator.provider.annotation.ProviderCtor;
import io.github.jordanmartin.datagenerator.provider.core.ValueProvider;
import io.github.jordanmartin.datagenerator.provider.core.ValueProviderException;
import io.github.jordanmartin.datagenerator.provider.object.IObjectProviderContext;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.time.Instant;
import java.time.LocalDate;
import java.time.ZoneId;
import java.time.temporal.ChronoUnit;
import java.util.Date;
import java.util.concurrent.ThreadLocalRandom;

/**
 * Génère une date aléatoire dans un interval donnée
 */
@Provider(
        name = "Date",
        description = "Returns a fixed or random date",
        examples = {
                "Date() => \"2020-11-23T21:42:03.367Z\"",
                "Date(\"2020-01-01\", \"2020-12-31\") => \"2020-10-20T21:42:03.367Z\"",
                "Date(Now(), \"2020-12-31\") => \"2020-10-20T21:42:03.367Z\"",
                "Date(Now(), DateAdd(Now(), 7, \"DAYS\")) => \"1978-10-21T16:09:10.187Z\"",
                "FormatDate(Date(), \"yyyy-MM-dd\") => 2021-03-22",
        },
        group = "date"
)
public class RandomDate implements ValueProvider<Date> {

    private ValueProvider<Date> fromProvider;
    private ValueProvider<Date> toProvider;

    /**
     * Par défaut, une date random entre l'année dernière et l'année prochaine courante
     */
    @ProviderCtor("Random date between D-365 and D+365 (D = current day)")
    public RandomDate() {
        fromProvider = (ctx) -> Date.from(Instant.now().minus(365, ChronoUnit.DAYS));
        toProvider = (ctx) -> Date.from(Instant.now().plus(365, ChronoUnit.DAYS));
    }

    @ProviderCtor("Random date between two specified date in string")
    public RandomDate(
            @ProviderArg(description = "Lower bound date (yyyy-MM-dd)") String from,
            @ProviderArg(description = "Upper bound date (yyyy-MM-dd)") String to
    ) {
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
        this.fromProvider = (ctx) -> {
            try {
                return sdf.parse(from);
            } catch (ParseException e) {
                throw new ValueProviderException(this, "Date format is not valid", e);
            }
        };
        this.toProvider = (ctx) -> {
            try {
                return sdf.parse(to);
            } catch (ParseException e) {
                throw new ValueProviderException(this, "Date format is not valid", e);
            }
        };
    }

    @ProviderCtor("Random date between two specified date")
    public RandomDate(
            @ProviderArg(description = "Lower bound date") Date from,
            @ProviderArg(description = "Upper bound date") Date to
    ) {
        this.fromProvider = (ctx) -> from;
        this.toProvider = (ctx) -> to;
    }

    @ProviderCtor("Random date between two date generated by two other provider")
    public RandomDate(
            @ProviderArg(description = "Lower bound date", examples = "Now()") ValueProvider<Date> from,
            @ProviderArg(description = "Upper bound date", examples = "DateAdd(Now(), 7, \"DAYS\")") ValueProvider<Date> to
    ) {
        this.fromProvider = from;
        this.toProvider = to;
    }

    @ProviderCtor("Date from a string (no random)")
    public RandomDate(
            @ProviderArg(description = "Date with the pattern yyyy-MM-dd") String date
    ) {
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
        this.fromProvider = (ctx) -> {
            try {
                return sdf.parse(date);
            } catch (ParseException e) {
                throw new ValueProviderException(this, "Date format is not valid", e);
            }
        };
        this.toProvider = null;
    }

    public RandomDate from(int year, int month, int day) {
        fromProvider = (ctx) -> getDate(year, month, day);
        return this;
    }

    public RandomDate to(int year, int month, int day) {
        toProvider = (ctx) -> getDate(year, month, day);
        return this;
    }

    private Date getDate(int year, int month, int day) {
        Instant instant = LocalDate
                .of(year, month, day)
                .atStartOfDay(ZoneId.systemDefault()).toInstant();
        return Date.from(instant);
    }

    @Override
    public Date getOneWithContext(IObjectProviderContext ctx) {
        Date from = this.fromProvider.getOneWithContext(ctx);
        if (toProvider == null) {
            return from;
        }
        Date to = this.toProvider.getOneWithContext(ctx);

        if (to.before(from)) {
            throw new IllegalArgumentException("Invalid date range, the upper bound date is before the lower bound.");
        } else if (from.equals(to)) {
            return from;
        } else {
            long offsetMillis = ThreadLocalRandom.current().nextLong(to.getTime() - from.getTime());
            return new Date(from.getTime() + offsetMillis);
        }
    }
}
